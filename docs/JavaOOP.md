# Конспект по ООП и Java

## Объектно-ориентированное программирование в Java

### 1. Какие виды классов есть в Java?
- **Обычные классы:** стандартные классы (например, `class Person`).
- **Абстрактные классы:** с ключевым словом `abstract`, нельзя создать экземпляр.
- **Вложенные классы:**
  - Статические вложенные: `static class Inner`.
  - Внутренние: внутри другого класса, связаны с его экземпляром.
- **Локальные классы:** внутри метода.
- **Анонимные классы:** без имени, для одноразового использования. 
- **Перечисления (enum):** для констант (например, `enum Color`).

### 2. Расскажи про вложенные классы. В каких случаях они применяются?
**Вложенные классы** — это классы, определённые внутри другого класса.  
**Типы:**
- **Статические вложенные:** не зависят от внешнего объекта, создаются как `Outer.Inner`.
- **Внутренние:** требуют экземпляр внешнего класса.

**Применение:**
- Логическая группировка (например, `Node` внутри `Tree`).
- Сокрытие реализации.

Пример:
```java
class Outer {
    static class StaticInner {
        void show() { System.out.println("Static"); }
    }
    class Inner {
        void show() { System.out.println("Inner"); }
    }
}
Outer.StaticInner si = new Outer.StaticInner();
Outer o = new Outer();
Outer.Inner i = o.new Inner();
```

### 3. Что такое локальный класс? Каковы его особенности?
Локальный класс — это класс, определённый внутри метода или блока кода. Виден только в этой области.  
**Особенности:**
- Не может иметь модификаторов доступа (`public`, `private`).
- Имеет доступ к локальным переменным метода, если они `final` или фактически неизменяемы.

Пример:
```java
void method() {
    final int x = 10;
    class Local {
        void print() { System.out.println(x); }
    }
    Local l = new Local();
    l.print(); // 10
}
```

### 4. Что такое анонимные классы? Где они применяются?
Анонимные классы — это классы без имени, создаваемые "на лету" для реализации интерфейса или переопределения метода.  
**Применение:**
- Обработчики событий (например, в Swing).
- Одноразовые реализации.

Пример:
```java
Runnable r = new Runnable() {
    public void run() { System.out.println("Running"); }
};
r.run(); // Running
```

### 5. Каким образом из вложенного класса получить доступ к полю внешнего класса?
Используй OuterClass.this.field для внутреннего класса.  
Пример:
```java
class Outer {
    int x = 5;
    class Inner {
        void print() { System.out.println(Outer.this.x); }
    }
}
```

### 6. Что такое перечисления (enum)?
`enum` — это специальный тип для представления фиксированного набора констант.  
Пример:
```java
enum Day {
    MONDAY, TUESDAY;
    void print() { System.out.println(this); }
}
Day.MONDAY.print(); // MONDAY
```
Может содержать поля, методы и конструкторы.

### 7. Как проблема ромбовидного наследования решена в Java?
Ромбовидное наследование (когда класс наследует один и тот же метод через разные пути) запрещено в Java для классов — множественное наследование классов не поддерживается. Для интерфейсов с `default` методами конфликт решается явным переопределением.

Пример:
```java
interface A { default void show() { System.out.println("A"); } }
interface B { default void show() { System.out.println("B"); } }
class C implements A, B {
    public void show() { System.out.println("C"); } // явное разрешение
}
```

### 8. Что такое конструктор по умолчанию?
Это конструктор без параметров, автоматически добавляемый компилятором, если в классе нет других конструкторов.

Пример:
```java
class Test {
    // public Test() {} — добавляется автоматически
}
```

### 9. Могут ли быть приватные конструкторы? Для чего они нужны?
Да, могут. Используются:
- В паттерне **Singleton** для ограничения создания экземпляров.
- В утилитных классах с только `static` методами.

Пример (Singleton):
```java
class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() { return instance; }
}
```

### 10. Чем отличаются конструкторы по умолчанию, копирования и с параметрами?
**По умолчанию:** без параметров, инициализирует поля значениями по умолчанию.
- `Test() {}`

**Копирующий:** принимает объект того же класса и копирует его поля.
- `Test(Test t) { this.x = t.x; }`

**С параметрами:** задаёт начальные значения полей.
- `Test(int x) { this.x = x; }`

### 11. Какие модификаторы доступа есть в Java? Какие применимы к классам?
**Модификаторы:**
- `public`: доступен всем.
- `protected`: доступен в пакете и подклассам.
- `default` (без модификатора): доступен в пакете.
- `private`: доступен только в классе.

Для классов: только `public` и `default` (внешние классы), вложенные могут быть любыми.

### 12. Может ли статический метод быть переопределён или перегружен?
**Переопределён:** нет, так как static методы принадлежат классу, а не объекту.  
**Перегружен:** да, если различаются параметры.  
Пример:
```java
class A {
    static void show() { System.out.println("A"); }
    static void show(int x) { System.out.println("A " + x); }
}
class B extends A {
    static void show() { System.out.println("B"); } // скрытие, а не переопределение
}
```

### 13. Могут ли нестатические методы перегрузить статические?
Да, так как перегрузка зависит только от сигнатуры, а не от `static`.  
Пример:
```java
class Test {
    static void method(int x) {}
    void method(String s) {}
}
```

### 14. Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?
**Уровень доступа:** нельзя сузить (например, `public` → `protected`), можно расширить (`protected` → `public`).  
**Тип возвращаемого значения:** можно сузить (ковариантность), если новый тип совместим с исходным.  
Пример:
```java
class A {
    public Object method() { return new Object(); }
}
class B extends A {
    public String method() { return "Hello"; } // String — подтип Object
}
```

### 15. Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и т.д.)?
**Сигнатура:** нельзя менять имя и параметры.  
**Модификаторы:**
- `throws`: можно добавлять или убирать совместимые исключения.
- Нельзя менять `static`, `final`, сужать доступ.

Пример:
```java
class A {
    void method() throws IOException {}
}
class B extends A {
    void method() throws FileNotFoundException {} // подтип IOException
}
```

### 16. Могут ли классы быть статическими?
Только вложенные классы могут быть `static`. Обычные внешние классы — нет.

### 17. Что означает модификатор final? К чему он может быть применим?
`final`:
- Переменные: константа (например, `final int X = 10;`).
- Методы: нельзя переопределить.
- Классы: нельзя унаследовать.

Пример:
```java
final class FinalClass {}
// class Sub extends FinalClass {} — ошибка
```

### 18. Что такое абстрактные классы? Чем они отличаются от обычных?
**Абстрактные классы:** объявлены с `abstract`, могут содержать абстрактные методы (без реализации). Нельзя создать экземпляр.  
**Отличия:**
- Обычные классы полностью реализованы и инстанцируются.
- Абстрактные служат базой для наследования.

Пример:
```java
abstract class Shape {
    abstract void draw();
}
```

### 19. Может ли быть абстрактный класс без абстрактных методов?
Да, чтобы запретить создание экземпляров или как базовый класс с общей логикой.  
Пример:
```java
abstract class Base {
    void method() { System.out.println("Base"); }
}
```

### 20. Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?
Да, могут. Используются для инициализации полей суперкласса при создании подклассов.  
Пример:
```java
abstract class Animal {
    String name;
    Animal(String name) { this.name = name; }
}
class Dog extends Animal {
    Dog() { super("Dog"); }
}
```

### 21. Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?
Интерфейс — это контракт, который определяет набор методов, которые класс должен реализовать. Он не содержит реализации методов (до Java 8), а только их сигнатуры. Интерфейсы позволяют задавать поведение, которое может быть реализовано разными классами, не нарушая принципа единственной ответственности.  
Модификаторы по умолчанию:
- Поля: `public static final`.
- Методы: `public abstract` (до Java 8).

Пример:
```java
interface I {
    int X = 10; // public static final
    void method(); // public abstract
}
```
- Начиная с Java 8 Интерфейсы могут содержать
  - Методы с реализацией, используя ключевое слово `default`.

  Пример:
  ```java
  public interface Logger {
      default void log(String message) {
          System.out.println("Log: " + message);
      }
  }
  ```
  - Статические методы  
  Пример:
  ```java
  public interface Utils {
      static int add(int a, int b) {
          return a + b;
      }
  }
  
  ```
  - Приватные методы (с Java 9)  
  Пример:
  ```java
  public interface Helper {
      private void helperMethod() {
          System.out.println("Private method in interface");
      }
  }
  
  ```
Вывод:  
- Поля всегда `public static final`.
- Методы без тела — `public abstract` (по умолчанию).
- Возможны `default`, `static` и `private` методы с реализацией.

### 22. Чем интерфейсы отличаются от абстрактных классов? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?
**Отличия:**
- Интерфейсы: только контракт, поддерживают множественное наследование.
- Абстрактные классы: могут содержать реализацию, только одиночное наследование.

**Когда использовать:**
- Интерфейс: для определения поведения (например, `Runnable`).
- Абстрактный класс: для общей реализации (например, `AbstractList`).

Пример:
```java
interface Flyable { void fly(); }
abstract class Vehicle { void start(); }
```

### 23. Может ли один интерфейс наследоваться от другого? От двух других?
Да, через `extends`. Поддерживается множественное наследование.  
Пример:
```java
interface A {}
interface B {}
interface C extends A, B {}
```

### 24. Что такое дефолтные методы интерфейсов? Для чего они нужны?
Default методы: методы с реализацией в интерфейсе (с Java 8). Позволяют добавлять функциональность без ломания существующих реализаций.  
Пример:
```java
interface I {
    default void show() { System.out.println("Default"); }
}
```

### 25. Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?
Если два интерфейса имеют одинаковый default метод, класс должен явно переопределить его.  
Пример:
```java
interface A { default void show() { System.out.println("A"); } }
interface B { default void show() { System.out.println("B"); } }
class C implements A, B {
    public void show() { A.super.show(); } // выбор реализации
}
```

### 26. Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?
Порядок:
- Статические блоки суперкласса.
- Статические блоки подкласса.
- Блоки инициализации суперкласса.
- Конструктор суперкласса.
- Блоки инициализации подкласса.
- Конструктор подкласса.

Пример:
```java
class Parent {
    static { System.out.println("Static Parent"); }
    { System.out.println("Init Parent"); }
    Parent() { System.out.println("Constructor Parent"); }
}
class Child extends Parent {
    static { System.out.println("Static Child"); }
    { System.out.println("Init Child"); }
    Child() { System.out.println("Constructor Child"); }
}
new Child();
// Вывод:
// Static Parent
// Static Child
// Init Parent
// Constructor Parent
// Init Child
// Constructor Child
```

### 27. Зачем нужны и какие бывают блоки инициализации?
**Зачем:** для инициализации полей до вызова конструктора.  
**Типы:**
- Обычные: выполняются при создании объекта.
- Статические: выполняются при загрузке класса.

Пример:
```java
class Test {
    int x;
    { x = 5; } // обычный
    static int y;
    static { y = 10; } // статический
}
```

### 28. Для чего в Java используются статические блоки инициализации?
Для инициализации статических полей или выполнения одноразовой логики при загрузке класса.  
Пример:
```java
class Config {
    static String setting;
    static { setting = loadConfig(); }
    static String loadConfig() { return "Loaded"; }
}
```

### 29. Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?
Если в обычном блоке — создание объекта прерывается, выбрасывается исключение.  
Если в статическом — класс не загружается, выбрасывается `ExceptionInInitializerError`.  
Пример:
```java
class Test {
    static { int x = 1 / 0; } // ArithmeticException
}
// ExceptionInInitializerError при загрузке
```

### 30. Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?
`ExceptionInInitializerError`, обёртывающее исходное исключение (например, `NullPointerException`).

### 31. Что такое класс Object?
`Object` — это суперкласс всех классов в Java. Любой класс неявно наследует его, если не указан другой суперкласс.  
Определяет базовые методы, доступные всем объектам.

### 32. Какие методы есть у класса Object (перечислить все)? Что они делают?
- `public String toString()`: возвращает строковое представление объекта (по умолчанию класс@хэш).
- `public boolean equals(Object obj)`: сравнивает объекты (по умолчанию по ссылкам).
- `public int hashCode()`: возвращает хэш-код объекта.
- `public final Class<?> getClass()`: возвращает класс объекта.
- `protected Object clone()`: создаёт копию объекта.
- `protected void finalize()`: вызывается перед сборкой мусора (устарел в Java 9).
- `public final void wait()`: приостанавливает поток.
- `public final void notify()`: возобновляет один поток.
- `public final void notifyAll()`: возобновляет все потоки.

### 33. Расскажи про equals и hashCode
- `equals`: сравнивает содержимое объектов. В `Object` сравнивает ссылки (`==`).
- `hashCode`: возвращает целочисленный хэш для использования в хэш-таблицах.

Связь: если equals возвращает true, hashCode должен быть одинаковым.


### 34. Каким образом реализованы методы hashCode() и equals() в классе Object?
- `equals`: `return this == obj;` — проверка ссылок.
- `hashCode`: возвращает уникальный хэш, основанный на адресе объекта в памяти (зависит от JVM).

### 35. Зачем нужен equals(). Чем он отличается от операции ==?
`equals`: сравнивает содержимое объектов (нужно переопределять).  
`==`: сравнивает ссылки.  
Пример:
```java
String s1 = new String("a");
String s2 = new String("a");
System.out.println(s1 == s2); // false
System.out.println(s1.equals(s2)); // true
```

### 36. Правила переопределения equals()
**Рефлексивность**: `x.equals(x) == true`.  
**Симметричность**: если `x.equals(y)`, то `y.equals(x)`.  
**Транзитивность**: если `x.equals(y)` и `y.equals(z)`, то `x.equals(z)`.  
**Консистентность**: многократный вызов даёт тот же результат.  
`null`: `x.equals(null) == false`.

### 37. Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?
Проблема: нарушение контракта — равные объекты будут иметь разные хэши, что сломает работу коллекций вроде `HashMap`.  
Пример:
```java
class Point {
    int x;
    public boolean equals(Object o) { return ((Point)o).x == x; }
}
HashMap<Point, String> map = new HashMap<>();
map.put(new Point(1), "A");
map.get(new Point(1)); // null — разные hashCode
```

### 38. Какой контракт между hashCode() и equals()?
Если `a.equals(b) == true`, то `a.hashCode() == b.hashCode()`.  
Обратное не обязательно: одинаковый `hashCode` не гарантирует равенство.

### 39. Для чего нужен метод hashCode()?
Для быстрого поиска и хранения объектов в хэш-таблицах (`HashMap`, `HashSet`).

### 40. Правила переопределения метода hashCode()
- Консистентность: результат не меняется при неизменных полях.  
- Равные объекты — равные хэши.  
- Желательно минимизировать коллизии.

### 41. Есть ли рекомендации о том, какие поля следует использовать при подсчёте hashCode()?
- Используй поля, участвующие в `equals()`.
- Комбинируй значения с множителем (например, 31) для уменьшения коллизий.

Пример:
```java
class Point {
    int x, y;
    public int hashCode() { return 31 * x + y; }
}
```

### 42. Могут ли у разных объектов быть одинаковые hashCode()?
Да, это называется коллизия. Хэш-функция ограничена 32 битами, а объектов может быть больше.

### 43. Почему нельзя реализовать hashCode(), который будет гарантированно уникальным для каждого объекта?
Тип `int` имеет 2^32 значений, а число объектов может быть бесконечным. Коллизии неизбежны (принцип Дирихле).

### 44. Есть класс Point {int x, y;}. Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?
x + y: даёт больше коллизий (например, `(1, 2)` и `(2, 1)` → 3).
31 * x + y: множитель 31 (простое число) увеличивает разброс значений, снижая коллизии.
Пример: `(1, 2)` → 33, `(2, 1)` → 63.

### 45. Чем a.getClass().equals(A.class) отличается от a instanceof A.class?
`a.getClass().equals(A.class)`: проверяет точное совпадение типа объекта a с классом A.  
`a instanceof A`: проверяет, является ли a экземпляром A или его подкласса.  
Пример:
```java
class A {}
class B extends A {}
A obj = new B();
System.out.println(obj.getClass().equals(A.class)); // false
System.out.println(obj instanceof A); // true
```