# Конспект по ООП и Java

## Основы ООП

### 1. Что такое ООП?
Объектно-ориентированное программирование (ООП) — это парадигма программирования, которая строится вокруг концепции объектов. Объекты — это экземпляры классов, где класс выступает как шаблон, определяющий свойства (поля, атрибуты) и поведение (методы). Основная идея ООП заключается в моделировании реального мира через программные сущности, что упрощает проектирование, разработку и поддержку сложных систем.

Пример: в программе для управления библиотекой можно создать класс `Book` с полями `title` и `author` и методами `borrow()` и `returnBook()`.

ООП отличается от процедурного программирования тем, что фокус смещается с последовательности действий на взаимодействие объектов. Это делает код более структурированным и интуитивно понятным.

### 2. Какие преимущества у ООП?
- **Модульность**: каждый объект — независимая единица, что упрощает тестирование, отладку и поддержку кода. Например, баг в классе `Car` можно исправить, не трогая `Driver`.
- **Переиспользуемость**: благодаря наследованию и полиморфизму код можно использовать повторно. Например, класс `Vehicle` может быть унаследован классами `Car` и `Truck`.
- **Инкапсуляция**: скрытие внутренней реализации объекта защищает данные и упрощает интерфейс. Например, приватное поле `balance` в классе `BankAccount` доступно только через методы `deposit()` и `withdraw()`.
- **Гибкость и масштабируемость**: новые функции добавляются через расширение классов или интерфейсов. Например, можно добавить класс `ElectricCar` к иерархии `Vehicle`.
- **Моделирование реального мира**: ООП позволяет представлять сложные системы через объекты. Например, в игре классы `Player`, `Enemy` и `Weapon`.
- **Упрощение работы в команде**: разделение на классы позволяет разработчикам работать параллельно.

### 3. Какие недостатки у ООП?
- **Сложность для простых задач**: для небольших программ (например, калькулятора) ООП может быть избыточным.
- **Производительность**: из-за абстракций (например, полиморфизма) ООП может быть медленнее процедурного кода.
- **Крутая кривая обучения**: новичкам сложно освоить наследование, полиморфизм и абстракцию.
- **Избыточность кода**: ООП может привести к созданию лишних классов или методов.
- **Сложность отладки**: из-за скрытия данных и связей между объектами поиск ошибок усложняется.

### 4. Основные принципы ООП
1. **Инкапсуляция**: объединение данных и методов в классе с ограничением доступа.
2. **Наследование**: механизм переиспользования свойств и методов суперкласса.
3. **Полиморфизм**: способность объектов вести себя по-разному в зависимости от реализации.
4. **Абстракция**: выделение ключевых характеристик объекта, скрывая детали.

### 5. Что такое инкапсуляция? (с примером)
Инкапсуляция — объединение данных и методов в классе с ограничением прямого доступа к данным через модификаторы (`private`, `public`) и предоставление интерфейса (геттеры/сеттеры).

**Зачем нужна**: защищает данные, скрывает реализацию, упрощает взаимодействие.

**Пример**:
```java
class Person {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name != null && !name.isEmpty()) {
            this.name = name;
        }
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if (age >= 0) {
            this.age = age;
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Person person = new Person();
        person.setName("Alice");
        person.setAge(25);
        System.out.println(person.getName() + ", " + person.getAge()); // Alice, 25
    }
}
```
Здесь данные name и age скрыты, а доступ к ним осуществляется только через методы, что позволяет контролировать изменения (например, запретить отрицательный возраст).

### 6. Что такое наследование? (с примером)
**Наследование** — это механизм ООП, который позволяет одному классу (подклассу или дочернему классу) унаследовать свойства и методы другого класса (суперкласса или родительского класса). Это обеспечивает повторное использование кода и создание иерархий классов.

**Зачем нужно:** уменьшает дублирование кода, позволяет расширять функциональность базового класса.

**Пример**:
```java
class Animal {
    protected String species;

    public Animal(String species) {
        this.species = species;
    }

    public void eat() {
        System.out.println("This " + species + " eats food.");
    }
}

class Dog extends Animal {
    public Dog() {
        super("Dog"); // вызов конструктора суперкласса
    }

    public void bark() {
        System.out.println("Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();  // This Dog eats food.
        dog.bark(); // Woof!
    }
}
```

Класс *Dog* наследует метод *eat()* от *Animal* и добавляет свой метод *bark()*. Ключевое слово *extends* указывает на наследование.

### 7. Что такое полиморфизм? (с примером)
**Полиморфизм** — это способность объекта вести себя по-разному в зависимости от его конкретного типа, даже если он рассматривается как объект более общего типа. В ООП полиморфизм делится на статический (перегрузка методов) и динамический (переопределение методов).

**Зачем нужен:** позволяет писать универсальный код, работающий с объектами разных типов через общий интерфейс.

**Пример динамического полиморфизма:**
```java
class Animal {
    public void sound() {
        System.out.println("Some generic sound");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("Meow");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Woof");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Cat(); // полиморфизм: ссылка типа Animal указывает на Cat
        myAnimal.sound(); // Meow

        myAnimal = new Dog();
        myAnimal.sound(); // Woof
    }
}
```

Здесь переменная *myAnimal* типа *Animal* может ссылаться на объекты *Cat* или *Dog*, а вызываемый метод *sound()* определяется во время выполнения (позднее связывание).

### 8. Что такое абстракция? (с примерами)
**Абстракция** — это процесс выделения общих характеристик объектов, скрывая детали их реализации. Она позволяет сосредоточиться на том, что делает объект, а не как он это делает. В ООП абстракция реализуется через абстрактные классы и интерфейсы.

**Зачем нужна:** упрощает проектирование, скрывает сложность и обеспечивает гибкость.

**Пример 1 (абстрактный класс):**
```java
abstract class Shape {
    protected String color;

    public Shape(String color) {
        this.color = color;
    }

    // Абстрактный метод — подклассы обязаны реализовать
    abstract void draw();

    // Конкретный метод
    public void describe() {
        System.out.println("This is a " + color + " shape.");
    }
}

class Circle extends Shape {
    public Circle(String color) {
        super(color);
    }

    @Override
    void draw() {
        System.out.println("Drawing a " + color + " circle.");
    }
}

public class Main {
    public static void main(String[] args) {
        Shape shape = new Circle("red");
        shape.draw();      // Drawing a red circle.
        shape.describe();  // This is a red shape.
    }
}
```
Здесь *Shape* задаёт общий контракт *(draw())*, а детали реализации оставлены подклассу *Circle*.

**Пример 2 (интерфейс):**
```java
interface Printable {
    void print();
}

class Document implements Printable {
    private String content;

    public Document(String content) {
        this.content = content;
    }

    @Override
    public void print() {
        System.out.println("Printing: " + content);
    }
}

public class Main {
    public static void main(String[] args) {
        Printable doc = new Document("Hello, world!");
        doc.print(); // Printing: Hello, world!
    }
}
```

Интерфейс *Printable* абстрагирует поведение печати, не заботясь о том, как это реализовано в *Document*.

### 9. Что такое ассоциация, агрегация и композиция?

**Это типы отношений между классами в ООП:**  
**Ассоциация:** общее отношение между двумя независимыми классами, где один "знает" о другом. Нет строгой зависимости.  
**Пример:** класс Teacher и класс Student. Учитель может преподавать студентам, но они существуют независимо.
```java
class Student {
    String name;
}
class Teacher {
    String name;
    Student[] students; // ассоциация
}
```
**Композиция:** отношение "часть-целое", где части не могут существовать без целого (сильная связь).  
**Пример:** класс House и класс Room. Комнаты не существуют без дома.
```java
class Room {
    String name;
}
class House {
    Room[] rooms; // композиция
    House() {
        rooms = new Room[]{new Room()};
    }
}
```
**Различия:** ассоциация — слабая связь, агрегация — слабая "часть-целое", композиция — сильная "часть-целое".

### 10. Расскажи про раннее и позднее связывание
**Раннее связывание (статическое):** выбор метода происходит на этапе компиляции. Это относится к перегрузке методов, вызову static или final методов, так как компилятор заранее знает, какой метод будет вызван.  
**Пример:**
```java
class Example {
    void method(int x) { System.out.println("Int"); }
    void method(String s) { System.out.println("String"); }
}
Example e = new Example();
e.method(5); // Int — компилятор знает, что выбрать
```
**Позднее связывание (динамическое):** выбор метода откладывается до выполнения программы и зависит от типа объекта во время выполнения. Это характерно для переопределения методов в полиморфизме.

**Пример:**

```java
class Parent {
    void show() { System.out.println("Parent"); }
}
class Child extends Parent {
    void show() { System.out.println("Child"); }
}
Parent obj = new Child();
obj.show(); // Child — решается во время выполнения
```
**Различие:** раннее связывание быстрее, но менее гибкое; позднее связывание медленнее, но поддерживает полиморфизм.

### 11. SOLID
- S (**Single Responsibility Principle** — Принцип единственной ответственности): каждый класс должен иметь только одну причину для изменения. Например, класс User не должен одновременно обрабатывать данные пользователя и записывать их в БД — для этого нужен отдельный класс UserRepository.
- O (**Open/Closed Principle** — Принцип открытости/закрытости): классы должны быть открыты для расширения (например, через наследование), но закрыты для модификации. Например, добавление новой фигуры в систему не должно менять код базового класса Shape.
- L (**Liskov Substitution Principle** — Принцип подстановки Барбары Лисков): объекты подкласса должны быть взаимозаменяемы с объектами суперкласса без изменения поведения программы. Например, если Rectangle наследует Shape, он не должен нарушать ожидания методов Shape.
- I (**Interface Segregation Principle** — Принцип разделения интерфейсов): клиенты не должны зависеть от интерфейсов, которые они не используют. Например, вместо одного большого интерфейса Worker лучше создать Eatable и Workable.
- D (**Dependency Inversion Principle** — Принцип инверсии зависимостей): высокоуровневые модули не должны зависеть от низкоуровневых; оба должны зависеть от абстракций. Например, класс OrderService зависит от интерфейса PaymentProcessor, а не от конкретной реализации PayPal.

### 12. Какие ещё принципы можешь назвать?
- **DRY** (Don’t Repeat Yourself): избегай дублирования кода, выноси общую логику в методы или классы. Например, вместо копирования кода валидации в каждом классе создай утилитный метод validateInput.
- **KISS** (Keep It Simple, Stupid): делай код максимально простым и понятным. Не усложняй решение, если есть простой способ.
- **YAGNI** (You Aren’t Gonna Need It): не добавляй функциональность, пока она не потребуется. Например, не создавай сложную систему кэширования, если текущие требования этого не предусматривают.
- **GRASP** (General Responsibility Assignment Software Patterns): набор шаблонов распределения обязанностей (например, "Controller" для управления взаимодействием).

