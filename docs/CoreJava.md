# Конспект по ООП и Java

## Базовые элементы языка Java

### 1. Какие примитивные типы данных есть в Java?
Java имеет 8 примитивных типов:
- `byte` (1 байт, -128 до 127) — для маленьких чисел.
- `short` (2 байта, -32768 до 32767) — для средних чисел.
- `int` (4 байта, -2^31 до 2^31-1) — стандартный целочисленный тип.
- `long` (8 байт, -2^63 до 2^63-1) — для больших чисел.
- `float` (4 байта, с плавающей точкой) — для дробных чисел (например, 3.14f).
- `double` (8 байт, с плавающей точкой) — для более точных дробных чисел (например, 3.14).
- `char` (2 байта, 0 до 65535) — для символов Unicode (например, 'A', 'Я').
- `boolean` (1 бит, `true`/`false`) — для логических значений.

Примитивы не являются объектами и хранятся напрямую в памяти.

### 2. Что такое char?
`char` — это 2-байтовый примитивный тип данных для хранения одного символа в кодировке Unicode. Он может представлять буквы, цифры, специальные символы и даже эмодзи.  
**Пример:** `char c = 'A';` или `char c = '\u0041';` (Unicode для 'A').
**Особенность:** занимает 2 байта, а не 1, как в C, чтобы поддерживать международные символы.

### 3. Сколько памяти занимает boolean?
Теоретически boolean занимает 1 бит, так как имеет два значения (true/false).  
**Однако в JVM размер зависит от реализации:**
- В массивах (`boolean[]`) — 1 байт на элемент.
- Как отдельная переменная — может занимать 4 байта (выравнивание в памяти).

Точный размер не стандартизирован и зависит от JVM.

### 4. Что такое классы-обёртки?
Классы-обёртки — это объектные аналоги примитивных типов, позволяющие использовать их в контексте, где требуются объекты (например, в коллекциях). Для каждого примитива есть обёртка:
- `Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`, `Character`, `Boolean`.

Пример: `Integer i = 10;` вместо `int i = 10;`.
Зачем нужны: коллекции (например, `List<Integer>`) не работают с примитивами.

### 5. Что такое автоупаковка и автораспаковка?
**Автоупаковка (Autoboxing):** автоматическое преобразование примитива в соответствующий класс-обёртку.  
**Пример:** `Integer i = 5;` (автоматически `Integer.valueOf(5)`).
**Автораспаковка (Unboxing):** обратное преобразование обёртки в примитив.  
**Пример:** `int x = i;` (автоматически `i.intValue()`).

Пример кода:
```java
List<Integer> list = new ArrayList<>();
list.add(5); // автоупаковка
int value = list.get(0); // автораспаковка
```
Введено в Java 5 для упрощения кода.

### 6. Что такое явное и неявное приведение типов (кастинг)? В каких случаях в Java нужно использовать явное приведение?
**Неявное приведение:** автоматическое преобразование типа меньшего размера или точности в больший без потери данных.  
**Пример:** `int i = 10;` `long l = i;` (безопасно, так как `long` больше `int`).  
**Явное приведение:** преобразование с указанием типа в скобках, часто с потерей данных.  
**Пример:** `double d = 5.7;` `int i = (int)d`; (результат: `5`, дробная часть отсекается).
**Когда нужно явное:**  
При сужении типа (например, `long` → `int`, `double` → `float`).  
При преобразовании между несовместимыми типами (например, `float` → `int`).

**Пример:**
```java
double d = 9.99;
int i = (int)d; // явное, результат 9
float f = 5.5f;
double dd = f; // неявное
```
### 7. Что такое пул интов?
**Пул интов** — это кэш объектов `Integer` в диапазоне от -128 до 127, который JVM создаёт автоматически для экономии памяти. При автоупаковке значения из этого диапазона ссылаются на один и тот же объект.

Пример:
```java
Integer a = 100;
Integer b = 100;
System.out.println(a == b); // true — один объект из пула
Integer c = 200;
Integer d = 200;
System.out.println(c == d); // false — разные объекты
```
### 8. Какие нюансы у строк в Java?
Строки в Java — это объекты класса `String`, которые:
- Неизменяемы: после создания строка не может быть изменена (все операции создают новый объект).
- Хранятся в пуле строк: строковые литералы (например, `hello`) кэшируются для экономии памяти.
- Сравнение: `==` проверяет ссылки, `equals()` — содержимое.

Пример:
```java
String s1 = "hello";
String s2 = "hello";
System.out.println(s1 == s2); // true — из пула
String s3 = new String("hello");
System.out.println(s1 == s3); // false — разные объекты
```
### 9. Что такое пул строк?
**Пул строк** — это специальная область в куче (Heap), где хранятся уникальные строковые литералы для повторного использования. Управляется JVM.  
**Как работает:** при создании строки через литерал (`"abc"`) JVM проверяет пул и возвращает существующий объект, если он есть.

Пример:
```java
String s1 = "cat";
String s2 = "cat";
System.out.println(s1 == s2); // true — один объект из пула
```
### 10. Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?
**Проблема:** `String` неизменяемы, и каждая операция вроде `+=` создаёт новый объект, что в цикле приводит к большим затратам памяти и времени.

Пример проблемы:
```java
String s = "";
for (int i = 0; i < 1000; i++) {
    s += "a"; // создаётся 1000 новых объектов
}
```
**Рекомендация:** использовать `StringBuilder` (непотокобезопасный) или `StringBuffer` (потокобезопасный).

**Пример решения:**
```java
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append("a"); // один объект, быстро
}
String result = sb.toString();
```
### 11. Почему строки не рекомендуется использовать для хранения паролей?
**Проблемы:**
- Неизменяемость: пароли остаются в памяти до сборки мусора.
- Пул строк: литералы паролей могут быть доступны через пул.

**Решение:** использовать `char[]`, который можно очистить вручную (например, `Arrays.fill(password, '0')`).
**Пример:** класс `Password` лучше реализовать с `char[]`, а не `String`.

### 12. Почему String неизменяемый и финализированный класс?
**Неизменяемость:**
- Обеспечивает безопасность (например, в качестве ключей в `HashMap`).
- Позволяет кэшировать строки в пуле.
- Упрощает многопоточность (нет необходимости в синхронизации).

**Финализированность (`final`):**
- Запрещает наследование, чтобы предотвратить изменение поведения (например, переопределение equals).

**Пример:** изменение String через наследование могло бы сломать пул строк.

### 13. Почему строка является популярным ключом в HashMap в Java?
**Причины:**
- Неизменяемость гарантирует стабильный hashCode.
- Хорошо реализованные `hashCode(`) и `equals(`) обеспечивают корректную работу хэш-таблиц.
- Удобство: строки — естественный способ представления ключей (например, "id", "name").

**Пример:** `HashMap<String, Integer> map = new HashMap<>(); map.put("age", 25);`.

### 14. Что делает метод intern() в классе String?
`intern()` добавляет строку в пул строк и возвращает ссылку на неё. Если строка уже есть в пуле, возвращается существующий объект.  

**Пример:**
```java
String s1 = new String("hello");
String s2 = s1.intern();
String s3 = "hello";
System.out.println(s2 == s3); // true — из пула
```

### 15. Можно ли использовать строки в конструкции switch?
Да, начиная с Java 7. Раньше `switch` поддерживал только `int`, `char`, `byte`, `short` и `enum`.  
**Пример:**
```java
String day = "Monday";
switch (day) {
    case "Monday": System.out.println("Start of week"); break;
    default: System.out.println("Other day");
}
```

### 16. Какая основная разница между String, StringBuffer, StringBuilder?
- **String:** неизменяемый, потокобезопасный за счёт неизменности, подходит для констант.
- **StringBuffer:** изменяемый, потокобезопасный (синхронизированные методы), медленнее из-за синхронизации.
- **StringBuilder:** изменяемый, не потокобезопасный, быстрее, чем `StringBuffer`.

Пример:
```java
String s = "hello";
StringBuffer sbf = new StringBuffer("hello");
StringBuilder sb = new StringBuilder("hello");
sb.append(" world"); // изменяет sb
```

### 17. Существуют ли в Java многомерные массивы?
Нет, в Java нет настоящих многомерных массивов. Есть массивы массивов (jagged arrays), где каждый элемент массива — это другой массив, и их размеры могут различаться.

**Пример:**
```java
int[][] matrix = new int[3][];
matrix[0] = new int[2];
matrix[1] = new int[3];
matrix[2] = new int[1]; // разные длины
```

### 18. Какими значениями инициализируются переменные по умолчанию?
Если переменные не инициализированы явно, они получают значения по умолчанию:
- `byte`, `short`, `int`, `long` → 0.
- `float`, `double` → 0.0.
- `char` → `\u0000` (нулевой символ).
- `boolean` → `false`.
- Объекты (включая обёртки) → `null`.

**Пример:**
```java
class Test {
    int x;
    Object o;
    public void print() {
        System.out.println(x + ", " + o); // 0, null
    }
}
```

### 19. Что такое сигнатура метода?
**Сигнатура метода —** это его имя и список параметров (типы и порядок), которые определяют уникальность метода в классе. Модификаторы, возвращаемый тип и исключения в сигнатуру не входят.

**Пример:**
```java
void method(int a, String b) {} // сигнатура: method(int, String)
void method(String b, int a) {} // другая сигнатура
```

### 20. Расскажи про метод main
`public static void main(String[] args)` — это точка входа в Java-программу:
- **public:** доступен извне JVM.
- **static:** вызывается без создания объекта класса.
- **void:** не возвращает значение.
- **String[] args:** массив аргументов командной строки.

**Пример:**
```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Args: " + args.length);
    }
}
```

### 21. Каким образом переменные передаются в методы, по значению или по ссылке?
В Java все переменные передаются по значению:
- Для примитивов: передаётся копия значения.
- Для объектов: передаётся копия ссылки, но сам объект остаётся тем же.

**Пример:**
```java
class Test {
    static void changeInt(int x) { x = 10; }
    static void changeObject(Person p) { p.name = "Bob"; }
}
class Person { String name; }
public class Main {
    public static void main(String[] args) {
        int a = 5;
        Test.changeInt(a);
        System.out.println(a); // 5 — копия

        Person p = new Person();
        p.name = "Alice";
        Test.changeObject(p);
        System.out.println(p.name); // Bob — тот же объект
    }
}
```

